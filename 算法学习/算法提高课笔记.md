### 前言
《算法基础课》的核心在于熟悉各类算法模板，相当于数学中的背定理和公式；而《算法提高课》的核心在于将问题抽象出一个模型，并使用之前学过的算法来进行解决，相当于数学中的对定理和公式的应用。
> 说实话感觉y总的算法提高课讲得确实要比基础课好很多，多了许多细节

### 一、动态规划
#### 1.1 数字三角形模型
<img src="算法提高课笔记.assets/image.png" alt="题目之间的关系" style="zoom: 33%;" />

相同模型中，每个题目之间都有一定的相关性，它们之间多为递进（或扩展）关系。

##### 1.1.1 闫氏DP分析法介绍（以摘花生的题为例）
* DP问题的新的思考方式——闫氏DP分析法（从**集合角度**来思考问题）
![闫氏DP分析法](算法提高课笔记.assets/image-1.png)
**关键点：**
1. 分为**状态表示**和**状态计算**两部分考虑
2. 状态表示是指用**一个状态来表示一个集合**，并且这个集合有一个具体的属性
3. 状态计算本质是**对集合进行划分**（并推导出状态转移方程）
> * 从上述分析可以得到每一个状态由哪些状态算出来
> * 在进行状态计算时考虑顺序问题，本题中的当前状态是有前面的状态计算而来，可以看成是一个拓扑序，因此行和列均从小到大进行枚举
> * 状态表示的维度一般怎么考虑：根据**经验**来，比如网格图一般用f[i][j]，线形图一般用f[i]，背包问题一般用f[i][j]（第一维表示物体，第二维表示容量）

##### 1.1.2 摘花生求解
**C++ 代码**
```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m;
int w[N][N];
int f[N][N];    // 状态表示：f[i][j]表示从(1, 1)走到(i, j)的所有路径集合（属性为max，即路径上的花生数量的最大值）

int main()
{
    int T;
    scanf("%d", &T);
    
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                scanf("%d", &w[i][j]);
        
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= m; j ++ )
                f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];  // 状态计算：(i, j)是由(i-1, j)或者(i, j-1)走过来的
        
        printf("%d\n", f[n][m]);
    }
    
    return 0;
}
```

##### 1.1.3 最低通行费
问题分析：由`2n-1`步可以推出，不能走回头路，所以本质上和**摘花生**这个题一样
![最低通行费分析](算法提高课笔记.assets/image-2.png)
**C++ 代码**
```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110, INF = 1e9;

int n;
int w[N][N];
int f[N][N];

int main()
{
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            scanf("%d", &w[i][j]);
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == 1 && j == 1) f[i][j] = w[i][j];    // 起点位置
            else
            {
                f[i][j] = INF;
                if (i > 1) f[i][j] = min(f[i][j], f[i - 1][j] + w[i][j]);   // 可以从上面走过来
                if (j > 1) f[i][j] = min(f[i][j], f[i][j - 1] + w[i][j]);   // 可以从左边走过来
            }
    
    printf("%d\n", f[n][n]);
    
    return 0;
}
```
> 注：求min值时可能需要特殊处理一下边界（比如该题，第0行和第0列的值都是0，若直接使用状态转移方程那么在求第1行和第1列的状态时最小值肯定是0，所以只能从第2行和第2列开始进行状态转移）

##### 1.1.4 方格取数
**要点：**
* 跟摘花生这个题类似，区别在于如何从走一次扩展到走两次？
> 解决思路：扩展一下状态维度，从`f(i, j)==>f(i1, j1, i2, j2)`
* 如何处理同一个格子不能被重复选择的问题？
> 解决思路：利用`i1 + j1 == i2 + j2`时两条路径的格子可能会重合这个性质来减少一维状态，然后每次在状态计算的时候判断这个格子是否重合，如果重合就只加一个方格的数，不重合就加两个方格的数

![方格取数思路](算法提高课笔记.assets/image-3.png)
**C++ 代码**
```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[N * 2][N][N];

int main()
{
    int a, b, c;
    
    scanf("%d", &n);
    
    while (cin >> a >> b >> c, a || b || c) w[a][b] = c;
    
    for (int k = 2; k <= n + n; k ++ )                          // k表示两条路径走过的行+列之和
        for (int i1 = 1; i1 <= n; i1 ++ )
            for (int i2 = 1; i2 <= n; i2 ++ )
            {
                int j1 = k - i1, j2 = k - i2;
                if (j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n)   // 判断边界
                {
                    int t = w[i1][j1];
                    if (i1 != i2) t += w[i2][j2];
                    int &x = f[k][i1][i2];
                    x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);   // 下 + 下
                    x = max(x, f[k - 1][i1 - 1][i2] + t);       // 下 + 右
                    x = max(x, f[k - 1][i1][i2 - 1] + t);       // 右 + 下
                    x = max(x, f[k - 1][i1][i2] + t);           // 右 + 右
                }
            }
    
    printf("%d\n", f[n + n][n][n]);
    
    return 0;
}
```

> 拓展：
> 1. k取方格数，即需要走k次然后求最大值【需要使用**最小费用流**（图的最优化问题）来做】
> 2. DP与最短路问题的联系：90%的DP问题可以转化成最短路问题，当图为拓扑图时，最短路问题也可以转为DP问题

